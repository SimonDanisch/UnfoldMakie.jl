	using Dierckx
	using ColorSchemes
	using GeometryTypes
	using Statistics
	using TimerOutputs
    using AlgebraOfGraphics
    using CategoricalArrays
    using PyMNE

"""
AoG recipe

See plot_topoplot for options; currently specifiable are positions,colormap,sensors,labels and levels.

Currently setting the interpolation method is not possible, I couldnt figure out how to specify the function to be used in @lift later
""" 
@recipe(Topoplot, data) do scene
    l_theme = default_theme(scene, Lines)
    Theme(
            positions= defaultLocations(),
            colormap= ColorSchemes.vik,
            sensors = true,
            labels = nothing,
            levels = 5,
#	    interpolation_method = spline2d_mne
            #colorrange=get(l_theme.attributes, :colorrange, automatic),
        )
end

"""
Overload Makie .plot! function to be used via AlgebraOfGraphics.jl
"""
function Makie.plot!(p::Topoplot)
	UnfoldMakie.plot_topoplot(p,p[:data],p[:positions];sensors=p[:sensors],colormap=p[:colormap])#,interpolation_method=p[:interpolation_method])

    #function update_plot(data)
    #    v = @lift(spline2d_mne(X,Y,xg,yg,$data;s=10^6) )
    #end
    #Makie.Observables.onany(update_plot, p[:data])

    p
end


#--- topoplot series
# plot_topoplot_series
# expects data to contain :time column, groups according to Δbin binsizes, plots topoplot series
# channels have to be in column :channel
plot_topoplot_series(data::DataFrame;Δbin,kwargs...) = plot_topoplot_series(data,Δbin;kwargs...)
"""
$(TYPEDSIGNATURES)


plot a series of topoplot. The function automatically takes the `combinefun=mean` over the :time column of `data` in `Δbin` steps.

`data` need column `:time` and `:channel`, and column `y=:estimate`

Further specifications via topoplotCfg for the topoplot recipe (XXX how to do ref?). In most cases user should provide the electrode positions via
    `topoplotCFG = (positions=pos,)` # note the trailling comma to make it a tuple

    `mappingCfg` is for the mapping command of AOG, typical usages would be `mappingCfg=(col=:time,row=:condition,)` to layout the plot. Topoplot modification via topoplotCfg as it is a visual
     

# Examples
Desc
```julia-repl
julia> data = DataFrame(:estimate=>repeat(1:63,100),:time=>repeat(1:20,5*63),:channel=>repeat(1:63,100)) # fake data
julia> pos = [(1:63)./63 .* (sin.(range(-2*pi,2*pi,63))) (1:63)./63 .* cos.(range(-2*pi,2*pi,63))].*0.5 .+0.5 # fake electrode positions
julia> plot_topoplot_series(data,5;topoplotCfg=(positions=pos,))
```

"""
function plot_topoplot_series(data::DataFrame,Δbin;y=:estimate,topoplotCfg=NamedTuple(),mappingCfg=(layout=:time,),combinefun=mean)

    
    # cannot be made easier right now, but Simon promised a simpler solution "soonish"
    axisOptions = (aspect = 1,xgridvisible=false,xminorgridvisible=false,xminorticksvisible=false,xticksvisible=false,xticklabelsvisible=false,xlabelvisible=false,ygridvisible=false,yminorgridvisible=false,yminorticksvisible=false,yticksvisible=false,yticklabelsvisible=false,ylabelvisible=false,
leftspinevisible = false,rightspinevisible = false,topspinevisible = false,bottomspinevisible=false,)

    data_mean = topoplot_timebin(data,Δbin;y=y,fun=combinefun)
    #@info data_mean
    
    AlgebraOfGraphics.data(data_mean)*mapping(y;mappingCfg...)*visual(Topoplot;topoplotCfg...)|>x->draw(x,axis=axisOptions)

end


"""
$(TYPEDSIGNATURES)

Split/Combine dataframe according to equally spaced time-bins

- `df` AbstractTable with fields :time and :channel
- `Δbin` bin-size

- `y` default :estimate, the column to combine (using `fun`) over
- `fun` function to combine, default is `mean`

"""
function topoplot_timebin(df,Δbin;y=:estimate,fun=mean)
	    tmin = minimum(df.time)
		tmax = maximum(df.time)
        
		bins = range(start=tmin+Δbin/2,step=Δbin,stop=tmax-Δbin/2)
        df = deepcopy(df) # cut seems to change stuff inplace
		df.time = cut(df.time,bins,extend=true)

        #df_m = combine(groupby(df,[:time,:channel]),y=>fun)
        df_m = combine(groupby(df,Not(y)),y=>fun)
        rename!(df_m,names(df_m)[end]=>y) # remove the _fun part of the new column
        return df_m

end;


"""
$(TYPEDSIGNATURES)

Topographical plots using Makie.jl Observables (can be updated faster).

- `data` vector or observable with data to plot as topoplot
- `positions` should be generated by MNE e.g. via 	`pos = PyMNE.channels.make_eeg_layout(PyMNE.get_info(raw)).pos`, centered at 0.5/0.5 with electrodes ranging from 0 to 1 in both dimensions


- `levels` ::int how many contour lines,::vector the exact contours,  ::nothing deactivates contour lines (default 5)
- `sensors` plot sensors (default: true)
- `colormap` default is ColorSchemes.vik
- `interpolation_method` default is using the PyMNE algorithm (`spline2d_dierckx` also available, but not really working right now)


"""
plot_topoplot(data,positions;kwargs...) = plot_topoplot(Axis(Figure()),data,positions;kwargs...)
plot_topoplot(h,data::Vector,positions;kwargs...) = plot_topoplot(h,Observable(data),positions;kwargs...) # convert to an observable, not sure if this is best practice ;)
#--- Actual Topoplot Function
function plot_topoplot(h,data::Observable,positions=defaultLocations();levels=5,labels=nothing,sensors=true,colormap= ColorSchemes.vik,interpolation_method=spline2d_mne)
        diameter = 1
        X,Y = position_to_2d(positions)
        xg,yg = generate_topoplot_xy(X,Y)
        v = @lift(interpolation_method(Y,X,yg,xg,$data) )
	#v = @lift(spline2d_mne(X,Y,xg,yg,$data))
        #@info v
        #xg,yg,v = generate_topoplot_grid(X,Y,data;method = spline2d_mne,s=10^6) 
        
        # remove everything in a circle (should be ellipse at some point)
        ix = sqrt.([i.^2+j.^2 for i in xg, j in yg]).> (diameter./2)
        v.val[ix] .= NaN

        ax = h
        heatmap!(ax,xg,yg,v,colormap=colormap)
         
        
        if !isnothing(levels)
        #contour!(ax,xg,yg,v,linewidth=3,colormap=colormap,levels=levels)
        end

        if to_value(sensors)
            draw_sensors(ax,X,Y)
        end
        draw_earNose(ax,diameter=diameter)
        draw_labels(ax,X,Y,labels)
        
        ax
end


"""
$(TYPEDSIGNATURES)

Scatter-plot of sensors
"""
function draw_sensors(ax,X,Y)
    scatter!(ax,X,Y,markersize=3,color="white",strokewidth=3,strokecolor="black") # add electrodes
end

"""
$(TYPEDSIGNATURES)

Annotate sensor-labels
"""
function draw_labels(ax,X,Y,::Nothing)
# in case of empty labels
end

function draw_labels(ax,X,Y,labels)
    pos = [(x,y) for (x,y) in zip(X,Y)]
    text!(ax,labels,position=pos,align=(:center,:center))

end

"""
$(TYPEDSIGNATURES)

If positions are given with more than two dimension, subset them to a 2D.

This function is likely to go away in the future 
"""
 position_to_2d(positions::Observable) = position_to_2d(to_value(positions))
function position_to_2d(positions::Matrix{T}) where {T<:Number}
    # mne layout positions
    return positions[:,1] .- 0.5,positions[:,2] .- 0.5
end

# default positions (maybe remove in future?)
function position_to_2d(positions::Vector{T}) where {T}
    # We could try some spherical mapping tool?
    X = first.(first.(positions)) 
    Y = last.(first.(positions))
    return X,Y
end

"""
$(TYPEDSIGNATURES)

Spline Interpolation basedon Dierckx irregular grid interpolation.
note !!!
    This function does not seem to work. Also I have to set the `s` parameter ultrahigh!
"""
function spline2d_dierckx(X,Y,xg,yg,data;s=10^6,kwargs...)
    spl = Spline2D(X, Y,to_value(data),kx=3,ky=3,s=s) 

    return evalgrid(spl,xg,yg) # evaluate the spline at the grid locs
end

"""
$(TYPEDSIGNATURES)

Spline Interpolation based on PyMNE's `_GridData`. This is not good practice, as we use internal function of MNE.
Also this is slow. If someone wants to take a deep dive, some kind of irregular grid interpoation would be very helpful here.

    
Would love to use Interpolations.jl, but their 2dsplines only work on a regular grid (as of v0.13)
https://github.com/JuliaMath/Interpolations.jl/issues/118

#interp_cubic = LinearInterpolation((X, Y), data)
#v=interp_cubic.(xg, yg)

"""
function spline2d_mne(X,Y,xg,yg,data;kwargs...)
        
        interp = PyMNE.viz.topomap._GridData([X Y], "head", [0,0], [1,1], "mean")
        #@info data
        interp.set_values(to_value(data))
        
        # the xg' * ones is a shorthand for np.meshgrid
        return interp.set_locations(xg' .* ones(length(yg)),ones(length(xg))' .* yg)()
end

"""
$(TYPEDSIGNATURES)

Generate x/y grid for interpolation

- `by` increases X/Y multiplactively by `by` to fill in the whole topoplot-circle
- `stepsize` the stepsize used to generate the grid; larger should be faster
"""
function generate_topoplot_xy(X,Y;	by = 0.6,stepsize=0.005)
  
	# get extrema and extend
    # this is for the axis view, i.e. whitespace left/right

	xlim = extrema(X) .+ abs.(extrema(X)).*[-by, by]
	ylim = extrema(Y).+ abs.(extrema(Y)).*[-by, by]
    # generate and evaluate a grid
	xg = range(xlim[1],stop=xlim[2],  step=stepsize)
	yg = range(ylim[1],stop=ylim[2], step=stepsize)


    return xg,yg
end
	
        


"""
$(TYPEDSIGNATURES)

Draw ear and nose, copied from stackoverflow
"""


function draw_earNose(ax;diameter = 0.2)

	# draw circle
	cx,cy = circleFun(center=(.0, .0), diameter=diameter, npoints = 100) # center on [.5, .5]
	lines!(ax,cx,cy,linewidth=3,color=:black)
	# draw nose
	nx = [-0.05, 0., .05].*diameter
	ny = [.5, .55, .5].*diameter
	lines!(ax,nx,ny,linewidth=3,color=:black)


			ear_x = [.497, .510, .518, .5299, .5419, .54, .547,.532, .510, .489].*diameter
			ear_y = [.0555, .0775, .0783, .0746, .0555, -.0055, -.0932, -.1313, -.1384, -.1199].*diameter
			lines!(ax,ear_x,ear_y,linewidth=3,color=:black) # right
			lines!(ax,-ear_x,ear_y,linewidth=3,color=:black) # left
end

"""
$(TYPEDSIGNATURES)

Draw the circle, there is a long discussion on MNE where to put the circle (tldr; as seen from above or at the ears/EAR)
"""
function circleFun(;center = (0,0),diameter = 1, npoints = 100)
    r = diameter / 2
    tt = range(0,stop=2*π,length = npoints)
    xx = center[1] .+ r * cos.(tt)
    yy = center[2] .+ r * sin.(tt)
    return (xx, yy)
  end



  """
$(TYPEDSIGNATURES)

This is a stub and likely will go away sooner or later.
"""
function defaultLocations()

    defaultlocs = """
    1	-18	0.34074074	FP1.
    2	18	0.34074074	FP2.
    3	-39	0.22222222	F3..
    4	39	0.22222222	F4..
    5	-90	0.17037037	C3..
    6	90	0.17037037	C4..
    7	-141	0.22222222	P3..D
    8	141	0.22222222	P4..
    9	-162	0.34074074	O1..
    10	162	0.34074074	O2..
    11	-54	0.34074074	F7..
    12	54	0.34074074	F8..
    13	-90	0.34074074	T3..
    14	90	0.34074074	T4..
    15	-126	0.34074074	T5..
    16	126	0.34074074	T6..
    17	0	0.17037037	FZ..
    18	180	0.17037037	PZ..
    19	-108	0.34074074	T5'.
    20	108	0.34074074	T6'.
    21	-144	0.34074074	O1'.
    22	144	0.34074074	O2'.
    23	-151	0.27407407	P3".
    24	151	0.27407407	P4".
    25	180	0.25555556	PZ".
    26	180	0.34074074	OZ..
    27	180	0.42592593	I...
    28	-162	0.42592593	CB1"
    29	162	0.42592593	CB2"
    30	-144	0.42592593	CB1.
    31	144	0.42592593	CB2.
    """
    
    positions = map(split(defaultlocs, "\n", keepempty=false)) do line
        pos = split(line, "\t")
        t, r = parse.(Float64, pos[2:3])
        t = deg2rad(t)
        p = Point2f0(r * cos(t), r * sin(t))
        n = replace(pos[2], "."=>"")
        return (p, n)
    end
    return positions

end
